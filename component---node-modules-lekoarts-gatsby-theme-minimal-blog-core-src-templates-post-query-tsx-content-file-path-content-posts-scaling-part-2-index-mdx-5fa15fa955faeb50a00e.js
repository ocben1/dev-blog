"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[359],{3769:function(e,n,t){t.r(n),t.d(n,{Head:function(){return l.F},default:function(){return s}});var a=t(7294),i=t(1151);function r(e){const n=Object.assign({h3:"h3",h4:"h4",p:"p",code:"code",strong:"strong",ol:"ol",li:"li",pre:"pre"},(0,i.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(n.h3,null,"Scenario: Enhancing a Learning Management System (LMS) Deployment"),"\n",a.createElement(n.h4,null,"Context:"),"\n",a.createElement(n.p,null,"As the root admin for ",a.createElement(n.code,null,"lms.educationapps.vic.gov.au"),", I'm responsible for ensuring the system is scalable, resilient, and performs efficiently under varying loads. This LMS is critical for delivering online education content to thousands of learners and instructors."),"\n",a.createElement(n.h3,null,"Horizontal Scaling with AWS Auto Scaling"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Challenge:"),"\nDuring peak usage times, such as the start of a new school term or during major online assessments, the LMS experiences significant spikes in traffic. The goal is to ensure the LMS can handle these spikes without performance degradation."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Solution:"),"\nI implemented AWS Auto Scaling to dynamically adjust the number of EC2 instances based on traffic load, ensuring consistent performance."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"How I did it:")),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Created an Auto Scaling Group:")," Configured an Auto Scaling Group (ASG) with a Launch Configuration specifying the AMI, instance type, and security groups. Set the minimum, maximum, and desired number of instances based on expected traffic patterns."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Configured Scaling Policies:")," Implemented target tracking scaling policies based on CPU utilization. This ensures that new instances are automatically launched when the CPU utilization of existing instances exceeds 70%, and instances are terminated when the utilization drops below 30%."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Integrated Load Balancer:")," Deployed an Elastic Load Balancer (ELB) to distribute incoming traffic across multiple EC2 instances in the ASG, ensuring even load distribution and high availability."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Continuous Monitoring:")," Used Amazon CloudWatch to monitor metrics and set alarms to trigger scaling activities, ensuring that the system automatically adjusts to changing traffic conditions."),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Outcome:"),"\nThe LMS maintained high performance and availability during peak times, with the system automatically scaling out to handle increased traffic and scaling in during off-peak times to optimize costs."),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-yaml"},'AWSTemplateFormatVersion: "2010-09-09"\nDescription: "AWS CloudFormation Template for Horizontal Scaling with Auto Scaling Group"\n\nParameters:\n  InstanceType:\n    Type: String\n    Default: t3.medium\n    Description: EC2 instance type\n\n  VPC:\n    Type: AWS::EC2::VPC::Id\n    Description: VPC for the Auto Scaling Group\n\n  SubnetIds:\n    Type: List<AWS::EC2::Subnet::Id>\n    Description: Subnet IDs for the Auto Scaling Group\n\nResources:\n  LaunchConfiguration: # Specifies the AMI, instance type, and security group for EC2 instances.\n    Type: AWS::AutoScaling::LaunchConfiguration\n    Properties:\n      ImageId: ami-0c55b159cbfafe1f0  # Replace with a valid AMI ID in your region\n      InstanceType: !Ref InstanceType\n      SecurityGroups:\n        - !Ref InstanceSecurityGroup\n      UserData:\n        Fn::Base64: |\n          #!/bin/bash\n          # Install and start the LMS application\n          yum update -y\n          yum install -y httpd\n          systemctl start httpd\n          systemctl enable httpd\n\n  AutoScalingGroup: # Manages the scaling of instances based on load, with a minimum size of 1, a maximum size of 5, and a desired capacity of 2.\n    Type: AWS::AutoScaling::AutoScalingGroup\n    Properties:\n      VPCZoneIdentifier: !Ref SubnetIds\n      LaunchConfigurationName: !Ref LaunchConfiguration\n      MinSize: 1\n      MaxSize: 5\n      DesiredCapacity: 2\n      TargetGroupARNs:\n        - !Ref TargetGroup\n      MetricsCollection:\n        - Granularity: "1Minute"\n      HealthCheckType: "EC2"\n      HealthCheckGracePeriod: 300\n\n  ScaleUpPolicy: # Defines target tracking policies to scale up based on CPU utilization.\n    Type: AWS::AutoScaling::ScalingPolicy\n    Properties:\n      AutoScalingGroupName: !Ref AutoScalingGroup\n      PolicyType: "TargetTrackingScaling"\n      TargetTrackingConfiguration:\n        PredefinedMetricSpecification:\n          PredefinedMetricType: ASGAverageCPUUtilization\n        TargetValue: 50.0\n\n  ScaleDownPolicy: # Defines target tracking policies to scale down based on CPU utilization.\n    Type: AWS::AutoScaling::ScalingPolicy\n    Properties:\n      AutoScalingGroupName: !Ref AutoScalingGroup\n      PolicyType: "TargetTrackingScaling"\n      TargetTrackingConfiguration:\n        PredefinedMetricSpecification:\n          PredefinedMetricType: ASGAverageCPUUtilization\n        TargetValue: 30.0\n\n  InstanceSecurityGroup: #Allows HTTP access to the instances.\n    Type: AWS::EC2::SecurityGroup\n    Properties:\n      GroupDescription: "Enable HTTP access"\n      VpcId: !Ref VPC\n      SecurityGroupIngress:\n        - IpProtocol: tcp\n          FromPort: 80\n          ToPort: 80\n          CidrIp: 0.0.0.0/0\n\n  TargetGroup: # Used by the load balancer to route traffic to the instances.\n    Type: AWS::ElasticLoadBalancingV2::TargetGroup\n    Properties:\n      VpcId: !Ref VPC\n      Port: 80\n      Protocol: HTTP\n      HealthCheckProtocol: HTTP\n      HealthCheckPort: "80"\n      HealthCheckPath: "/"\n      Matcher:\n        HttpCode: "200"\n      TargetType: instance\n\nOutputs:\n  AutoScalingGroupName:\n    Description: "Auto Scaling Group Name"\n    Value: !Ref AutoScalingGroup\n')),"\n",a.createElement(n.h3,null,"Vertical Scaling with Kubernetes on AWS"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Challenge:"),"\nCertain compute-intensive operations within the LMS, such as video processing or large-scale data analysis, required more resources than initially provisioned. The goal was to ensure these operations could be performed efficiently without over-provisioning resources during regular usage."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Solution:"),"\nI leveraged Kubernetes to manage containerized applications, allowing for vertical scaling of specific pods to handle resource-intensive tasks."),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"How I did it:")),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Deployed Kubernetes Cluster:")," Set up a Kubernetes cluster on AWS using Amazon EKS (Elastic Kubernetes Service). Deployed the LMS application as a set of microservices within the cluster."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Implemented Vertical Pod Autoscaler (VPA):")," Configured the Vertical Pod Autoscaler to automatically adjust the CPU and memory requests and limits for specific pods based on their observed usage. This ensured that resource-intensive tasks received the necessary resources while maintaining efficient resource utilization during normal operations."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Utilized Horizontal Pod Autoscaler (HPA):")," In addition to VPA, used the Horizontal Pod Autoscaler to scale the number of pods based on traffic load. This provided a dual-layered approach to scaling, handling both high traffic and resource-intensive operations."),"\n",a.createElement(n.li,null,a.createElement(n.strong,null,"Monitoring and Optimization:")," Implemented monitoring using Prometheus and Grafana to track resource usage and performance metrics. Continuously optimized resource requests and limits based on real-time data."),"\n"),"\n",a.createElement(n.p,null,a.createElement(n.strong,null,"Outcome:"),"\nThe LMS efficiently handled compute-intensive operations by vertically scaling specific pods, while also maintaining the ability to horizontally scale the entire application during high traffic periods. This dual-scaling approach ensured optimal performance and resource utilization. By leveraging AWS Auto Scaling for horizontal scaling and Kubernetes for both horizontal and vertical scaling, I ensured that the LMS was capable of handling varying loads and resource-intensive tasks efficiently. These implementations improved the system's scalability, resilience, and performance, contributing to a better user experience for students and teachers relying on the LMS."),"\n",a.createElement(n.h4,null,"Steps:"),"\n",a.createElement(n.ol,null,"\n",a.createElement(n.li,null,"Create an EKS cluster using CloudFormation."),"\n",a.createElement(n.li,null,"Use Kubernetes manifests to configure Vertical Pod Autoscaler (VPA) for specific pods."),"\n"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-yaml"},'AWSTemplateFormatVersion: "2010-09-09"\nDescription: "AWS CloudFormation Template for EKS Cluster"\n\nParameters:\n  ClusterName:\n    Type: String\n    Default: "eks-cluster"\n    Description: "The name of the EKS cluster"\n\n  NodeInstanceType:\n    Type: String\n    Default: t3.medium\n    Description: "EC2 instance type for the EKS worker nodes"\n\n  NodeGroupSize:\n    Type: Number\n    Default: 2\n    Description: "The desired number of worker nodes"\n\nResources:\n  EKSCluster: #Creates an EKS cluster with worker nodes.\n    Type: AWS::EKS::Cluster\n    Properties:\n      Name: !Ref ClusterName\n      ResourcesVpcConfig:\n        SubnetIds: \n          - subnet-12345678  # Replace with your Subnet IDs\n          - subnet-87654321  # Replace with your Subnet IDs\n        SecurityGroupIds: \n          - !Ref NodeSecurityGroup\n\n  NodeGroup: #Manages the worker nodes using an Auto Scaling Group.\n    Type: AWS::AutoScaling::AutoScalingGroup\n    Properties:\n      DesiredCapacity: !Ref NodeGroupSize\n      MinSize: 1\n      MaxSize: 4\n      VPCZoneIdentifier: \n        - subnet-12345678  # Replace with your Subnet IDs\n        - subnet-87654321  # Replace with your Subnet IDs\n      LaunchConfigurationName: !Ref NodeLaunchConfig\n      TargetGroupARNs:\n        - !Ref TargetGroup\n\n  NodeLaunchConfig:\n    Type: AWS::AutoScaling::LaunchConfiguration\n    Properties:\n      InstanceType: !Ref NodeInstanceType\n      ImageId: ami-0c55b159cbfafe1f0  # Replace with a valid EKS optimized AMI ID\n      SecurityGroups:\n        - !Ref NodeSecurityGroup\n      UserData:\n        Fn::Base64: |\n          #!/bin/bash\n          /etc/eks/bootstrap.sh eks-cluster\n\n  NodeSecurityGroup:\n    Type: AWS::EC2::SecurityGroup\n    Properties:\n      GroupDescription: "EKS worker nodes security group"\n      VpcId: vpc-12345678  # Replace with your VPC ID\n      SecurityGroupIngress:\n        - IpProtocol: tcp\n          FromPort: 0\n          ToPort: 65535\n          SourceSecurityGroupId: !Ref ControlPlaneSecurityGroup\n\n  ControlPlaneSecurityGroup:\n    Type: AWS::EC2::SecurityGroup\n    Properties:\n      GroupDescription: "EKS control plane security group"\n      VpcId: vpc-12345678  # Replace with your VPC ID\n\nOutputs:\n  ClusterName:\n    Description: "EKS Cluster Name"\n    Value: !Ref ClusterName\n  NodeInstanceType:\n    Description: "EKS Node Instance Type"\n    Value: !Ref NodeInstanceType\n  NodeGroupSize:\n    Description: "EKS Node Group Size"\n    Value: !Ref NodeGroupSize\n')),"\n",a.createElement(n.h3,null,"Kubernetes Manifest for Vertical Pod Autoscaler (VPA):"),"\n",a.createElement(n.pre,null,a.createElement(n.code,{className:"language-yaml"},'apiVersion: autoscaling.k8s.io/v1\nkind: VerticalPodAutoscaler # Configures VPA to automatically adjust the CPU and memory requests and limits for the LMS deployment based on observed usage.\nmetadata:\n  name: lms-vpa\nspec:\n  targetRef:\n    apiVersion: "apps/v1"\n    kind:       Deployment\n    name:       lms-deployment\n  updatePolicy:\n    updateMode: "Auto"\n---\napiVersion: apps/v1\nkind: Deployment # Defines the LMS application deployment with initial resource requests and limits, which can be adjusted by VPA.\nmetadata:\n  name: lms-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: lms\n  template:\n    metadata:\n      labels:\n        app: lms\n    spec:\n      containers:\n      - name: lms-container\n        image: my-lms-image:latest  # Replace with your LMS image\n        resources:\n          requests:\n            cpu: "500m"\n            memory: "1Gi"\n          limits:\n            cpu: "1000m"\n            memory: "2Gi"\n')))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?a.createElement(n,e,a.createElement(r,e)):r(e)},l=t(7636);function s(e){return a.createElement(l.Z,e,a.createElement(o,e))}l.Z}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-scaling-part-2-index-mdx-5fa15fa955faeb50a00e.js.map